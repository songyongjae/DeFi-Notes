# <b>1. DeFi(Decentralized Finance)란?</b>
DeFi는 **블록체인(Blockchain)** 기술을 기반으로 기존 금융 시스템(중앙화 체계)을 **탈중앙화(Decentralization)** 구조로 대체하는 금융 서비스를 의미합니다. 특히 **이더리움(Ethereum)** 네트워크에서 제공되는 **스마트 계약(Smart Contract)** 기능이 핵심이며, 일반적으로 디앱(dApp, 분산 애플리케이션)으로 구동됩니다.   
  
스마트 계약을 이용하면 **제3의 중개자(금융기관, 은행 등)** 없이도 거래 및 서비스 제공이 가능해집니다. 예를 들어, 탈중앙화 거래소(DEX)를 통해 중앙 거래소처럼 주문과 결제가 이루어지는 것이 아니라, **P2P(Peer-to-Peer)** 방식으로 유저들끼리 직접 거래할 수 있습니다. 이러한 메커니즘을 통해 신용 리스크(`Risk of Default`)를 한곳(중앙기관)에 집중시키지 않으며, **암호학 기반 디지털 서명**과 합의 알고리즘(`Consensus Algorithm`, 예: `PoS`, `PoW` 등)을 통해 신뢰를 형성합니다.

또한 DeFi에서는 **담보 대출, 예금, 파생상품, 보험, 자산 토큰화** 등 다양한 금융 서비스를 탈중앙화된 형태로 제공하며, 참여자는 이더리움 지갑(예: `Metamask`)만 있으면 전 세계 어디서든 접근할 수 있습니다. 이는 전통 금융에서 한계가 있었던 여러 문제(고비용 수수료, 지역 제한, 접근성 문제 등)의 솔루션으로 주목받고 있습니다.

**기회(Opportunities)**

(1) 금융 서비스 접근성 향상
- **소외계층의 금융 진입 장벽 완화**  
  전통적인 금융 시스템에서 신용도나 지역, 각종 규제로 인해 금융 서비스를 이용하지 못하던 인구(예: 신용점수가 없는 농가, 저개발국 지역 주민 등)도 지갑 생성만으로 금융 활동을 할 수 있게 합니다.  
- **사례: `Aave` 플랫폼의 담보 대출**  
  예를 들어, **`Aave`** 같은 대표적인 대출 플랫폼에서 암호화폐를 담보로 대출을 받아 농업 장비를 구매한 후 이를 통해 소득을 창출하는 모델이 보고된 바 있습니다. 대출 심사나 국가 간 송금 규제를 거치지 않고도, **스마트 계약**을 통해 신속하게 대출을 실행할 수 있기 때문입니다.  
- **기술적 근거**  
  - **탈중앙화 지표(`Decentralized Metrics`)**: 참여자 수, 스마트 계약 내 사용자 지갑 수 등이 지표로 측정되며, 전 세계에서 동일 조건으로 참여 가능하다는 점이 **소비자 이익**을 증명합니다.  
  - **분산 네트워크 토폴로지(`Topology`)**: 블록체인 네트워크가 중간 중앙서버 없이 **P2P** 노드 간 연결로 구성되기 때문에, 특정 지역 사용자만 차단하기가 어려워 더 폭넓은 접근성을 제공합니다.

(2) 투자 수익률 향상
- **고이자 Staking 및 유동성 제공(`Liquidity Providing`)**  
  DeFi 플랫폼은 일반적으로 전통 금융 대비 연 이자율(`APR`, `Annual Percentage Rate`)이 높게 설정된 예치 상품을 제공합니다. 이는 유동성 풀(`AMM`, `Automated Market Maker`)에 유동성을 공급하거나, 특정 프로젝트의 Staking에 참여함으로써 높은 보상을 받을 수 있는 구조입니다.  
- **사례: `Uniswap` 등 DEX 유동성 공급 수익**  
  자동화 마켓 메이커(`AMM`)를 활용하는 탈중앙화 거래소(**`Uniswap`, `SushiSwap` 등**)에서 토큰 거래가 발생할 때마다 발생하는 수수료를 유동성 공급자가 나누어 가지기 때문에, 전통 금융(예: 은행 정기 예금)의 이자율보다 몇 배 이상 높은 수익을 기대할 수 있습니다.  
- **기술적 근거**  
  - **수익률 계산식(`APR`/`APY`)**:  

    <!-- $$
    APR = \left( \frac{\text{Transaction Fee} + \text{Reward Token}}{\text{Deposited Asset Value}} \right) \times 100\%
    $$ -->
    ![APR Formula](https://latex.codecogs.com/svg.latex?\color{green}APR%20=%20\left(%20\frac{\text{Transaction%20Fee}%20+%20\text{Reward%20Token}}{\text{Deposited%20Asset%20Value}}%20\right)%20\times%20100\%)


    이 때 거래 빈도, 거래 규모가 커질수록 유동성 공급자의 수익률이 상승합니다.  
  - **가격 변동성과 무영향성 손실(`Impermanent Loss`)**:  
    두 자산 쌍의 가격이 큰 폭으로 변동할 경우, **유동성 풀**에 있는 자산 비율 변화로 인해 발생하는 무영향성 손실도 존재하지만, 수수료 수입 등으로 이를 상쇄하거나 초과 수익을 얻는 경우도 많습니다.

<img src="https://raw.githubusercontent.com/songyongjae/Hands-On-SQC/main/src/figure/fig1.png" alt="Flashbots Simulator Algorithm" style="width:650px;max-width:100%;">

**위험(Risks)**

(1) 스마트 계약의 보안 취약점
- **코드 결함 및 해킹 위험**  
  DeFi는 **스마트 계약**에 의해 자동으로 동작하므로, 코드 취약점이 발견될 경우 해커의 공격 표적이 되기 쉽습니다. 전통적인 금융기관(중앙 서버)과 달리, 한 번 해킹이 발생하면 되돌리기 어려운 구조이기 때문에 피해가 큰 편입니다.  
- **사례: `Ronin` 네트워크 해킹 사건(2022년)**  
  2022년 발생한 `Ronin` 해킹에서는 약 **6억 달러** 상당의 자산이 탈취되었습니다. 이는 스마트 계약이나 브릿지(서로 다른 블록체인을 연결하는 프로토콜) 보안이 취약하면 대규모 자금이 위험에 노출된다는 것을 보여준 대표 사례입니다.  
- **기술적 배경**  
  - **암호학적 안전성(`Cryptographic Security`)**:  
    스마트 계약에서 사용되는 암호화 기법(예: **`ECDSA`**, **`SHA-3`** 등)이 안전한지 여부가 전체 자산 보호에 직결됩니다. 매우 복잡한 수학적 문제를 기반으로 보안을 유지하지만, **코드 구현**에서 버그가 발생하면 사고가 날 수 있습니다.  
  - **형식 검증(`Formal Verification`)**:  
    안정성을 높이기 위해 스마트 계약 코드를 **수학적 검증 방법론**(형식 검증 툴, 정리 증명 시스템 등)으로 점검하는 절차가 개발 중이지만, 아직 모든 프로젝트에 보편화된 것은 아닙니다.

(2) 시장 변동성과 유동성 부족
- **가격 변동성(`Volatility`)로 인한 리스크**  
  암호화폐 시장은 전통 금융시장보다 가격 급등·급락이 빈번합니다. 따라서 DeFi에서 담보물의 가치가 단기간에 크게 하락하면 담보 부족으로 인한 강제 청산(`Liquidation`)이 발생할 수 있습니다.  
- **사례: 담보 자산 급락으로 인한 청산**  
  예를 들어, 대출 프로토콜(예: `MakerDAO`, `Compound`)에서 이더리움을 담보로 자금을 빌렸을 때, 이더리움 가격이 급락하면 담보 가치가 필요한 기준 이하로 떨어져 자동 청산되어 손실을 입게 됩니다.  
- **기술적 배경**  
  - **가격 변화에 따른 담보비율(C) 계산**:  
  
    <!-- $$
    C = \frac{\text{Collateral Asset Value}}{\text{Loan Amount}} \times 100\%
    $$ -->
    ![Collateral Ratio](https://latex.codecogs.com/svg.latex?\color{green}C%20%3D%20%5Cfrac%7B%5Ctext%7BCollateral%20Asset%20Value%7D%7D%7B%5Ctext%7BLoan%20Amount%7D%7D%20%5Ctimes%20100%5C%25)
    
    만약 이 지표가 특정 임계치(예: 150%) 아래로 내려가면 자동 청산 로직이 실행됩니다.  
  - **유동성 공급-소비 균형**:  
    유동성이 부족한 상태에서 대규모 매도(또는 매수)가 진행되면, 짧은 시간 안에 시세가 급변하여 심각한 손실을 발생시킬 수 있습니다. 이는 **`Order Book`** 기반 거래소보다 AMM 형태의 DEX에서 가격 슬리피지(`Slippage`)를 더욱 크게 만들 수도 있습니다.


---

## <b>2. DeFi 프로토콜내 경쟁</b>

- 암호화폐 퀀트 회사는 `유동성 풀(Liquidity Pool)`에 자금을 제공하여 수수료와 보상을 통해 수익을 창출할 수 있습니다. 자동화된 알고리즘을 통해 **최적의 유동성 풀**을 선택하고 **수익성**을 극대화하는 전략을 사용할 수 있습니다.  
  - 예를 들어 **Uniswap, Curve**와 같은 DEX(탈중앙화 거래소)에 유동성을 제공하거나, **Aave, Compound** 같은 대출 플랫폼에서 `스테이블코인`을 예치·대출하여 이자를 얻을 수 있습니다.  
  - **기술적 배경**:  
    - 유동성 풀이 활용되는 **AMM(Automated Market Maker)** 알고리즘은 대표적으로 `x * y = k`(Uniswap V2 형태) 또는 **Curve의 스테이블코인 최적화 곡선** 등을 이용하며, 각 풀마다 **슬리피지**, **수수료 구조**가 달라지므로 이를 **수리적 모델**로 분석하여 `Expected Return`을 계산해야 합니다.  
    - **수익 극대화**를 위해선 유동성 공급 시 발생하는 **무손실 수익**과 일시적 손실(Impermanent Loss)을 동시에 고려하는 **정량적 전략**이 필요합니다. 예를 들어, 다음과 같은 근사 공식을 통해 포트폴리오의 **Price Impact**를 추정할 수 있습니다.
        <!-- $$
        \text{Impermanent Loss} = 1 - \sqrt{\frac{P_{\text{end}}}{P_{\text{start}}}}
        $$   -->
        ![Impermanent Loss](https://latex.codecogs.com/svg.latex?\color{green}\text{Impermanent%20Loss}%20=%201%20-%20\sqrt{\frac{P_{\text{end}}}{P_{\text{start}}}})

    - 대규모 자금을 짧은 시간에 옮기기 위해선 **가스 비용 최적화**나 **트랜잭션 우선순위(MEV, Miner Extractable Value)** 방어전략이 필수입니다. 특히, 자금 이동 시 발생하는 **가스비**를 모델링하고, 체인별(이더리움, 레이어2 등)로 수수료를 비교 분석하여 최적 경로를 찾는 것은 정수계획법(Integer Programming)이나 **조합최적화** 기법으로 접근할 수 있습니다.  
    - 여러 유동성 풀(예: Curve, Uniswap, SushiSwap 등)의 스왑 수수료 구조, 슬리피지 등을 실시간 계산하는 **거래 로직** 설계가 필요합니다. 이를 위해 빠른 의사결정을 지원하는 **알고리즘 트레이딩 플랫폼**과 블록체인 네트워크 상태(트랜잭션 처리량, 평균 블록 타임 등)를 고려하는 **동적 재조정(Dynamic Rebalancing)** 알고리즘을 사용합니다.

- DEX에서 가격 `차익거래(Arbitrage)` 또는 시장 비효율성을 탐지하는 알고리즘을 사용해 `고빈도 거래`를 실행합니다. 스마트 계약을 활용하면 거래 프로세스가 자동화되고, 신속한 체결로 시장 기회를 포착할 수 있습니다.
  - 예시로 **SushiSwap**과 **Balancer** 간의 토큰 가격 차이를 탐지하여 자동으로 차익거래 기회를 포착하거나, 플래시 론(Flash Loan)을 활용하여 무담보 대출을 받은 뒤 짧은 시간에 여러 프로토콜을 순환 거래(Loop Trading)하는 방식도 가능합니다.  
  - **기술적 배경**:  
    - 차익거래 봇(Arbitrage Bot) 구현 시 블록 단위로 거래를 추적하고, 특정 범위 내에서 거래를 성공시키기 위해 **트랜잭션 우선순위 제어**(가스 수수료 상향, Flashbots 등)를 고려해야 합니다. 차익거래 전략은 `다중 경로 탐색 알고리즘`(예: 벨만–포드 알고리즘 등)을 통해 **토큰 간 교환 비율**을 종합적으로 계산하고, **최대 이익**을 주는 경로를 찾습니다.  
    - **플래시 론**을 사용할 경우, 같은 트랜잭션 내에서 대출→거래→상환이 이루어지므로, 여러 프로토콜을 순차적으로 호출하는 **멀티콜(Multicall)** 로직이 필요합니다. 이때 트랜잭션 원자성(Atomicity)을 보장하기 위해 스마트 계약에서 **여러 함수 호출**이 실패 시 전체 거래가 롤백되도록 설계해야 하며, 이는 **이산수학**에서의 그래프 순회와 **블록체인 VM(가상 머신)** 로직(예: EVM 바이트코드)을 함께 이해해야 합니다.  

**DeFi 프로토콜들과 경쟁 시 중요한 점**

- DeFi 프로토콜의 가장 큰 취약점 중 하나는 스마트 계약의 `보안 문제`입니다. 퀀트 회사가 자체 프로토콜을 운영하거나 DeFi와 경쟁한다면, **스마트 계약**의 코드 검증과 <b>보안 감사(Security Audit)</b>를 통해 신뢰를 제공해야 합니다.  
  - 예를 들어, **Formal Verification**(형식 검증), 다양한 **테스트넷** 환경에서의 시뮬레이션, 그리고 **버그 바운티** 프로그램 운영 등이 필요합니다.  
  ```solidity
    // 재진입 공격 예시😈
    contract ReentrancyAttack {
        VulnerableBank public vulnerableBank;
        constructor(address _vulnerableBankAddress) {
            vulnerableBank = VulnerableBank(_vulnerableBankAddress);
        }
        // fallback 함수: 재진입 공격 트리거
        fallback() external payable {
            if (address(vulnerableBank).balance >= 1 ether) {
                vulnerableBank.withdraw(1 ether);
            }
        }
        function attack() public payable {
            require(msg.value >= 1 ether, "Send at least 1 Ether");
            vulnerableBank.deposit{value: 1 ether}();
            vulnerableBank.withdraw(1 ether);
        }
        // 공격 계약의 잔액 확인
        function getBalance() public view returns (uint256) {
            return address(this).balance;
        }
    }
  ```
  
  <br>
  <img src="https://raw.githubusercontent.com/songyongjae/Hands-On-SQC/main/src/figure/fig3.png" alt="Flashbots Simulator Algorithm" style="width:650px;max-width:100%;">
  <br>

  ```solidity
    //공격 방지를 위한 Deadlock(Mutex)👼
    bool private locked;

    modifier noReentrant() {
        require(!locked, "No reentrancy");
        locked = true;
        _;
        locked = false;
    }

    function withdraw(uint256 _amount) public noReentrant {
        require(balances[msg.sender] >= _amount, "Insufficient balance");
        balances[msg.sender] -= _amount;
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success, "Failed to send Ether");
    }
  ```

  - **기술적 배경**:  
    - 오픈소스 코드 레포지토리에 대한 버전 관리(Git)와 자동화된 테스트(CI/CD) 프로세스를 통해 변경 사항을 추적·관리합니다. **형식 검증**은 스마트 계약이 지정된 **명세**(specification)를 만족하는지 **논리적 증명**(Theorem Proving)으로 확인하는 과정이며, 특히 금전 취급 로직(Deposit/Withdraw 함수 등)을 세부적으로 점검할 수 있습니다.  
    - **오라클(Oracle)** 문제를 해결하기 위해 Chainlink 같은 **탈중앙화 오라클**을 사용해 외부 데이터를 안전하게 가져옵니다. 오라클 데이터는 금융 시계열 분석(ARIMA, GARCH 모델 등)으로도 활용되어, 실시간으로 위험도(Risk Level)를 산정하거나 비정상적인 시장 변동성을 감지하는데 쓰일 수 있습니다.

- DeFi는 종종 `사용자 경험(UI/UX)`이 복잡하다는 비판을 받습니다. 퀀트 회사는 사용자 친화적 **인터페이스**와 쉽게 접근 가능한 서비스를 제공하여 기존 DeFi 프로토콜보다 우위를 점할 수 있습니다.  
  - 예를 들어 **간단한 스테이킹 인터페이스**, **명확한 리스크 관리 정보 제공**, **24/7 고객 지원** 등 꾸준한 개선사항에 집중해야 합니다.  
  - **기술적 배경**:  
    - 지갑 연동(메타마스크, 월렛커넥트 등)의 호환성 최적화가 필수입니다. 이를 위해 **반응형 웹(Responsive Web)** 디자인과 지갑 연결 프로토콜(예: WalletConnect)에 대한 **API 호출** 방식을 효율적으로 구현해야 합니다.  
    - 복잡한 스마트 계약 호출 과정을 **단순화된 UI**로 추상화해야 합니다. 여기서 **A/B 테스트** 및 **인간-컴퓨터 상호작용(HCI)** 연구 방법론을 적용하면 사용성이 크게 개선될 수 있습니다.

---

## <b>3. 김치 프리미엄</b>

**김치 프리미엄**은 한국 내 암호화폐 가격이 `해외 시장 가격보다 더 높은` 현상을 말합니다. 이러한 현상은 주로 `수요와 공급의 불균형`, `규제`, `심리적 요인` 등으로 인해 발생합니다. 암호화폐 특성 상 여러 개의 거래소가 소유한 독자적인 코인 유동성을 기준으로 거래가 운영되기 때문에 시세 차이가 발생하듯이, `한국 특유의 엄격한 규제` 때문에 얻게 되는 한국 투자자의 손해율을 의미합니다.

- 형성 요소 :
  - 한국은 외환 거래 및 자본 이동이 엄격히 규제되며, `외환 송금 한도`가 제한적입니다. 이는 글로벌 시장과의 자본 흐름을 제한하여 국내 시장에서의 암호화폐 공급 부족을 초래합니다.  
    - **기술적 배경**:  
      - 외환 규제와 자본 이동의 제한은 **거시경제학**에서 말하는 자본 이동성(Capital Mobility)을 떨어뜨리며, 국내 시장에서는 <b>총공급(AS)</b>이 상대적으로 축소됩니다. 이때 <b>총수요(AD)</b>가 일정 이상 유지되면 가격이 상승하게 되고, 이는 **수요-공급 곡선** 관점에서 김치 프리미엄을 유발합니다.
  - 한국은 암호화폐 투자에 대한 높은 관심을 보이는 국가 중 하나로, 투자 심리와 수요가 다른 국가보다 높습니다. 특히, 시장이 과열될 경우 개인 투자자 `FOMO(Fear of Missing Out)`의 영향이 큽니다.
  - 한국 내 개인 투자자들이 해외 거래소를 이용하기 어려운 경우(언어 장벽, 법적 제한) 국내 거래소에 집중되면서 가격이 상승할 수 있습니다.

- 가장 **근본적인 원인**은 자본 이동 제한 및 규제입니다. 한국은 `외환 관리법`과 `자본시장법`으로 인해 글로벌 시장과 자유롭게 자본을 교환하기 어렵습니다. 이는 국내 암호화폐 시장의 독립성을 강화하고, 수요와 공급의 불균형을 심화시켜 김치 프리미엄을 형성합니다.  
  - **기술적인 표현**:  
    - 김치 프리미엄은 보통 아래와 같이 정의됩니다.

    <!-- $$
    \text{Kimchi Premium} \; (\text{KP}) = \left(\frac{\text{Domestic Exchange Price} - \text{Foreign Exchange Price}}{\text{Foreign Exchange Price}}\right) \times 100\%
    $$ -->
    ![Kimchi Premium](https://latex.codecogs.com/svg.latex?\color{green}\text{Kimchi%20Premium}%20(\text{KP})%20=%20\left(\frac{\text{Domestic%20Exchange%20Price}%20-%20\text{Foreign%20Exchange%20Price}}{\text{Foreign%20Exchange%20Price}}\right)%20\times%20100\%)

    - 규제로 인해 국내외 가격이 **즉시 균형화**되지 못하고, 해외 대비 국내 가격이 지속적으로 높게 형성되면, 위 KP 수치가 커집니다.

<br>
<img src="https://raw.githubusercontent.com/songyongjae/Hands-On-SQC/main/src/figure/fig2.jpg" alt="Flashbots Simulator Algorithm" style="width:650px;max-width:100%;">
<br>

**암호화폐 차익거래의 유형**
- **결정론적 차익거래:** 이는 트레이더가 두 거래소에서 디지털 자산을 동시에 매수하고 매도하여 시장 비효율성에서 이익을 취하는 것입니다. 트레이더는 두 거래소에서 차익거래 기회를 찾아 가장 낮은 가격으로 자산을 매수합니다. 그런 다음 다른 거래소에서 매도합니다.
- **삼각 차익거래:** 한 거래소에서 세 개의 암호화폐 쌍의 가격이 서로 상관관계가 없는 경우, 특히 그 중 하나가 일시적으로 가격이 낮을 때 수익을 얻을 수 있습니다. 트레이더는 비트코인을 에이다(ADA)로 거래하고, ADA를 이더리움으로 전환한 다음, 이더리움으로 다시 비트코인을 거래할 수 있습니다. 목표는 더 많은 비트코인을 얻는 것입니다.
- **시스템 트레이딩:** 유니스왑이나 팬케이크스왑과 같은 탈중앙화 거래소(DEX)특성을 활용하여 차익 거래를 할 수 있습니다. 특정 자산의 가격이 저평가되거나 고평가된 경우, 차익거래자는 다양한 유동성 풀을 사용해 디지털 자산을 사고 팔 수 있습니다. 또한, 자동화된 거래 체결을 통해 차익거래자는 수익성을 높이면서 몇 분 안에 수백 건의 거래를 체결할 수 있습니다.


**김치 프리미엄을 통한 거래 기회**
- **차익/역차익 거래** : 해외에서 암호화폐를 저렴하게 구매한 후, 한국 거래소에서 더 높은 가격에 판매하여 차익을 얻는 방식입니다. 그러나, `외환 송금 한도`, `KYC/AML 규제`, `거래 속도 제한` 등이 장애물로 작용할 수 있습니다. 환율 변동과 암호화폐 가격 차이를 동시에 이용하여 차익을 극대화할 수 있습니다. 요즘처럼 `원화 환율이 상승`할 때, 해외에서 달러로 암호화폐를 구매 후 한국에서 매도하여 차익 실현하는 전략이 사용됩니다.
  - **기술적 배경**:  
    - 차익거래 시 발생하는 이익을 간단히 표현하면,

    <!-- $$
    \text{Arbitrage Profit} = \Big(\text{Domestic Selling Price} - \text{Foreign Buying Price}\Big) \times \text{Trading Volume} \;-\; \text{Remittance Cost} \;-\; \text{Fees}
    $$ -->
    ![Arbitrage Profit](https://latex.codecogs.com/svg.latex?\color{green}\text{Arbitrage%20Profit}%20=%20\Big(\text{Domestic%20Selling%20Price}%20-%20\text{Foreign%20Buying%20Price}\Big)%20\times%20\text{Trading%20Volume}%20-%20\text{Remittance%20Cost}%20-%20\text{Fees})

    - 블록체인 네트워크를 통한 암호화폐 전송 속도, **월렛 보안**, 그리고 **국가 간 송금 소요 시간** 등을 함께 고려해야 합니다.
- **파생상품 및 선물 거래** : 블록체인의 스마트 컨트랙트를 활용한 `디지털 파생상품`이 존재합니다. 김치 프리미엄이 높은 시점에서 선물 시장을 활용하여 가격 변동을 예측한 거래 전략을 실행할 수 있습니다. 비트코인 선물 시장에서 롱(Long) 또는 숏(Short) 포지션을 통해 프리미엄의 확장 또는 축소를 활용할 수 있습니다.
  - **기술적 배경**:  
    - 선물 가격 결정 모델(예: 코스트 오브 캐리(Cost of Carry) 모델)에서 국내 금리 및 해외 금리, 김치 프리미엄으로 인한 현물 가격 차이를 반영한 **매수·매도 전략**을 자동화할 수 있습니다.  
    - 파생상품 포지션을 잡을 때 <b>헤징(hedging)</b>을 위한 **델타 중립(Delta-Neutral)** 전략 등을 수립하여 현물시장과 선물시장의 가격차를 극대화하는 방법이 자주 활용됩니다.
- **P2P, DApp, NFT 등 응용 방식`(에어드롭)`** : 글로벌 P2P 네트워크를 통해 암호화폐를 저가로 구매 후, 국내에서 프리미엄이 붙은 가격으로 `개인 간 거래(P2P)`를 통해 차익 실현할 수 있습니다. `해외에서 암호화폐를 구매`한 후 DeFi 플랫폼에서 스테이블코인으로 전환하여, 이를 `국내에서 매도`하거나 유동성을 제공하는 방법도 있습니다. 그리고, FT나 스테이블코인을 활용해 `김치 프리미엄`을 간접적으로 활용하며 해외에서 스테이블코인을 구매 후 국내 거래소에서 암호화폐로 전환해 매도 전략 등을 전개해 나갈 수 있습니다.
  - **기술적 배경**:
    - <b>탈중앙화 거래소(DEX)</b>를 통한 개인 간 매매 시, **AMM(Automated Market Maker)** 알고리즘을 사용하는 풀에 유동성을 제공하거나, 개인 간 교환(OTC) 방식으로 직접 거래할 수 있습니다.  
    - DeFi 프로토콜과 **스테이블코인**을 결합하는 경우, 각각의 프로토콜 수수료 구조(예: 스왑 수수료, 유동성 공급 보상)를 정량화해 최적의 수익경로를 찾는 **최적화 모델**(Linear/Nonlinear Optimization)을 적용할 수 있습니다.

---

## <b>4. 온체인 분석</b>

온체인 분석은 거래 내역과 다양한 지갑 간 이동을 추적하여, 실제로 거래소가 “고객들의 자산을 온전히 보관하고 있는지”를 살펴볼 수 있는 중요한 수단입니다. 특히 FTX 사태 이후, 다수의 거래소들이 **`Proof of Reserves(준비금 증명)`** 개념을 도입했지만, 여전히 온체인 데이터와의 교차 검증이 필수적입니다.  
(온체인 데이터는 블록체인 상의 모든 트랜잭션이 투명하게 기록된다는 특성 덕분에, 거래소의 실제 보유 자산을 제3자가 직접 확인할 수 있게 해줍니다.)

**(1) 빗썸의 코인 잔고를 온체인 데이터로 분석하는 방법**

1. **주요 입출금 지갑(Hot/Cold Wallet) 식별**  
    - **거래소 지갑 주소 공개**: 빗썸 등 주요 거래소는 일정 범위 내에서 콜드월렛 주소(또는 일부 Hot Wallet 주소)를 공개하기도 합니다. 공개된 주소에 대해, 실제 온체인 트랜잭션(이더리움, BSC, 트론 등 해당 체인)을 모니터링해 **발표 내용과 실제 잔고**가 일치하는지 확인합니다. (예: 이더리움 체인에서 다음 형태로 계정별로 추적 가능) 
   

    - ![Balance](https://latex.codecogs.com/svg.latex?\color{green}\text{Balance}%20=%20\sum%20\text{ERC}%20-%20\text{20%20Token%20Holdings}%20+%20\text{ETH%20Balance})


    - **개인별 입금주소(Deposit Address) 구조 파악**: 사용자가 빗썸에 코인을 입금할 때 부여되는 “전용 주소”가 어느 스마트 컨트랙트(또는 EOA) 형태인지, 어떤 패턴으로 생성되는지 조사할 수 있습니다. 이러한 지갑들이 **최종적으로 어느 메인 콜드월렛으로 집금되는지**(거래소 내부 송금 경로)를 추적하면, 빗썸이 관리하는 지갑 전체의 네트워크 구조를 파악할 수 있습니다.  
    - **기술적 배경**:  
        - 온체인 지갑 클러스터링에는 **그래프 이론**(노드·엣지 구조)과 **주소 레이블링** 기법이 사용됩니다. 예컨대, 지갑들을 노드(`Node`)로, 트랜잭션을 엣지(`Edge`)로 간주하여 반복적인 주소 간 트랜잭션 패턴(입출금 흐름, `nonce`, 가스 사용량 등)을 관찰하면, 다수의 주소가 사실상 하나의 운영 주체(예: 빗썸)에 속한다는 사실을 식별할 수 있습니다.  
        - 또한, 네트워크 상에서 특정 주소들이 반복적으로 같은 지점(콜드월렛)에 자금을 모은다면, 이 주소들을 같은 “클러스터”로 묶어 **한 조직이 사용하는 지갑 집합**이라고 추정할 수 있습니다.

2. **보유 잔액과 고객 예치금(부채) 비교**  
    - **온체인 잔고 확인**: 예를 들어, 빗썸이 “우리는 CRV 토큰을 X만큼 보유 중”이라고 발표했다면, 실제로 해당 콜드월렛(또는 관련 지갑들)의 CRV 토큰 잔고를 확인해 합산합니다. (이때 다음 형태로 계산) 


    - ![Total Holdings](https://latex.codecogs.com/svg.latex?\color{green}\text{Total%20Holdings}%20=%20\sum_{i=1}^{n}%20\text{Wallet}_i(\text{CRV%20Balance}))


    - **체인별 이중 확인**: 일부 코인은 여러 체인(이더리움, BNB Chain, Tron 등)에 걸쳐 발행되므로, 해당 토큰이 여러 네트워크에서 동시에 유통될 수 있습니다. 모든 체인에서 빗썸의 관련 지갑을 식별해 전체 보유량을 추적해야 ‘총보유량’을 알 수 있습니다. (예컨대, 이더리움에서의 CRV와 BNB Chain에서의 BEP-20 CRV를 모두 더해야 정확한 총량이 산출됨)  
    - **기술적 배경**:  
        - 단순한 잔고 증명(`PoR`, `Proof of Reserves`)만으로는 “빗썸이 실제로 이렇게 많은 코인을 소유하고 있다”는 점은 보여줄 수 있지만, “해당 코인이 고객 예치금 총합과 정확히 일치하는가?”는 별개의 문제입니다.  
        - 거래소 준비금 검증 시 **머클 트리(`Merkle Tree`) 기반 기법**으로 사용자별 예치 자산 총합과 공개된 온체인 잔고를 비교하는 방식이 이상적이나, 실제로는 각 거래소가 부채(고객 자산)에 관한 완전한 데이터를 투명하게 공개하지 않는 경우가 많습니다.  
       즉, 해당 비율이 1 이상인지 확인하는 것이 중요합니다.<br>
       <!-- $$
       \text{Reserves Ratio} = \frac{\text{On-chain Assets}}{\text{Total Liabilities}}
       $$ -->
        - ![Reserves Ratio](https://latex.codecogs.com/svg.latex?\color{green}\text{Reserves%20Ratio}%20=%20\frac{\text{On-chain%20Assets}}{\text{Total%20Liabilities}})


<br>
<img src="https://raw.githubusercontent.com/songyongjae/Hands-On-SQC/main/src/figure/fig5.png" alt="Flashbots Simulator Algorithm" style="width:650px;max-width:100%;">
<br>

3. **이상 징후 확인**  
   - **대규모 외부 출금 패턴**: 특정 시점에 콜드월렛에서 ‘알 수 없는 주소’로 큰 금액이 이동했고, 그 뒤로 다시 회수되지 않는다면, 거래소가 고객 자산을 다른 곳에 활용(운용, 대출 등)하고 있을 가능성을 의심해야 합니다. (예: 하루 만에 수만 ETH가 콜드월렛에서 빠져나갔다면, 해당 주소의 최종 종착지를 추적하여 실제 회수가 이루어졌는지 체크)  
   - **빈번한 Cross-Chain 이동**: `BRIDGE`, Cross-Chain Swap 등을 통해 자금을 여러 체인으로 분산시키거나, 다른 거래소·DeFi 플랫폼으로 반복 이동시키는 모습이 포착된다면 내부 자금 운용을 의심할 수 있습니다. (예: 빗썸 콜드월렛에서 자금이 브리지 컨트랙트로 이동 후, 다시 BNB Chain으로 옮겨지는 패턴이 꾸준히 발견될 경우, “운용”을 위한 자금 분산 가능성)  
   - **주기적 컨트랙트 호출**: 콜드월렛에서 특정 컨트랙트(DeFi 대출 프로토콜 등)로 자금이 주기적으로 입출금된다면, 단순히 “보관” 목적이 아니라 “운용”중일 가능성을 고려해야 합니다. (예: AAVE나 Compound 등으로의 반복적인 입·출금이 지속 발생하면, 거래소 측이 고객 자산으로 예치·대출을 진행하는 신호일 수 있음)

**(2) FTX 사례를 통한 ‘온체인 자산 검증’의 중요성**

1. **FTX 파산 이전, 온체인에서 포착된 징후**  
   - FTX가 알라메다 리서치(`Alameda Research`)와 긴밀히 연결되어 있었다는 사실은, 온체인 트랜잭션 분석을 통해 **두 지갑 간 대규모 자금 흐름**이 포착되면서도 이미 일부 커뮤니티에서 의심을 샀습니다.  
   - 하지만 FTX 측은 “고객 자산은 1:1로 보관 중”이라고 강조해왔기 때문에, 많은 투자자들이 이를 대수롭지 않게 여겼습니다. (결국에는 두 회사 간 내부 거래로 인해 FTX 고객 자산이 대규모로 유출·활용되었음이 드러남)

2. **Proof-of-Reserves(준비금 증명)의 한계**  
   - 거래소가 스냅샷 시점에 **외부에서 코인을 빌려 일시적으로 지갑에 채워 넣는** 방식으로 준비금을 **부풀리는** 사례가 보고되었습니다.  
   - 온체인 상에 나타난 지갑 잔고만 확인했을 때는 정상으로 보이지만, 실제로는 부채(고객 예치금) 규모를 초과하는 자산을 보유 중인지 알 수 없습니다. (이때, 스냅샷 직전 $\Delta t$ 동안 대여받아 일시적으로 지갑을 채운 뒤, 스냅샷 후에 다시 반납하는 패턴이 가능)  
   - 따라서 **단순 잔고 증명**이 아닌, **부채(고객 총예치금) 대비 자산 비율**까지 투명하게 검증할 수 있어야 진정한 안정성을 확인할 수 있습니다. 즉, 다음 조건이 상시 충족되는지 여부를 확인하는 것이 핵심입니다.<br>
   <!-- $$
   \frac{\text{On-chain Assets at Snapshot}}{\text{Customer Deposits}} \ge 1
   $$ -->
   ![On-chain Assets Snapshot](https://latex.codecogs.com/svg.latex?\color{green}\frac{\text{On-chain%20Assets%20at%20Snapshot}}{\text{Customer%20Deposits}}%20\geq%201)


3. **실제 모니터링 시 유의할 점**  
   - **부채(예치금)와의 비교가 핵심**: 단순히 “콜드월렛이 1만 BTC를 보유한다”고 공개했더라도, 고객들이 예치한 BTC가 2만 개라면 실질적으로 자산이 절반만 확보된 상태입니다.  
   - **거래소 내부 지갑 간 자전거래**: 지갑 구조가 복잡한 거래소일수록, 내부 지갑끼리 물량을 옮기며 **유동성을 착시**시키는 수법이 가능해집니다. 한 지갑에서 다른 지갑으로 이동했다가 다시 되돌아오는 패턴을 단순히 “순입금”으로 착각하지 않도록 주의해야 합니다. (온체인에서 보면 트랜잭션 건수만 많아 보여도, 실질 자금 흐름이 반복되는 자전거래일 수 있음)  
   - **온체인에 잡히지 않는 오프체인 부채**: 거래소가 고객 예치 자산을 담보로 기관 대출을 받는 등 오프체인에서 부채를 늘렸을 경우, 온체인에서 보이는 잔고만으로는 위험 수준을 알기 어렵습니다. 결국 **온체인 데이터와 오프체인 회계장부**를 동시에 살펴야 종합적인 판단이 가능합니다.

**요약**  
- 빗썸 등 거래소가 “고객 자산을 실제로 1:1로 보관”하고 있는지 확인하려면, **(1) 거래소 주요 지갑 식별 → (2) 온체인 잔고 확인 → (3) 이 잔고가 실제 고객 예치금 규모와 맞는지 교차 검증**하는 과정이 필요합니다.  
- 온체인 분석 툴(`Etherscan`, `BscScan`, `Dune Analytics`, `Nansen` 등)을 활용해 빗썸 주요 주소들의 **실시간 잔고 흐름**, **의미 있는 대규모 이동**, **Cross-Chain 이동** 등을 추적함으로써 “외부 운용” 의심 여부를 보다 정확히 판단할 수 있습니다. (궁극적으로, 해당 방식이 병행되어야 완전한 안전성을 담보합니다.) $$\text{On-chain Verification} + \text{Off-chain Audit}$$ 
- FTX 사례에서 드러났듯, 단순히 지갑 잔액을 공개하는 것만으로는 충분하지 않습니다. **부채 구조와 준비금 스냅샷 조작** 같은 허점을 주의해야 합니다.  


---

# <b>Quick Example & Solution</b>

**철수는 10 ETH를 가지고 있는데, 이 이더리움을 자신이 소유한 지갑 100개로 분산해서 보관하고자 합니다. 철수는 다음과 같은 사실을 알고 있습니다.**

- **기본 이더리움 전송의 gas limit (=블록체인 연산량) 은 항상 21,000 이다.**
- **이더리움 네트워크에서, 트랜잭션을 기록할 때는 gas limit * gas price 만큼의 수수료를 소모한다.**
- **gas price 는 실시간 이더리움 네트워크의 사용량으로 결정된다. 즉 철수가 컨트롤 할 수 없다.**
- **하나의 지갑에서, 하나의 트랜잭션을 통해 이더리움을 전송하기 위해서는 컨트랙트를 사용해야 한다.**

**철수는 이더리움 네트워크 상에서 자신이 사용하는 수수료를 절약하고 싶고, 이를 위해 컨트랙트를 통해 이더리움을 동시에 전송할때 소모되는 gas limit 을 최소화 하고 싶습니다.**

**이를 위해 철수는 온체인 분석을 통해 여러개 이더리움을 한번에 송금하는 트랜잭션을 찾아봤는데, 고민에 빠졌습니다.<br><br>**

#### **1번 트랜잭션**
- 0x9b11e595e6d0e5f8e292b55e5d1dd124c6f21ba2da4408b347777167047220b0

**425개 지갑에 총 216.75 ETH를 전송했고, 이때 소모된 gas limit 은 4,335,552입니다.**

**하나의 트랜잭션에서 이더리움을 보내고, 이 트랜잭션을 425번 반복했다면, 이때 소모된 gas limit 은 21,000 * 425= 8,925,000 이었을 것입니다.**

**이 트랜잭션은 컨트랙트를 사용해 이더리움을 한꺼번에 보내면서 블록체인 기록에 등록되는 수수료를 아낄 수 있었습니다.<br><br>**

#### **2번 트랜잭션** 
- 0x568bdb0ebd2315a35f25eb5bce2efc46ef979143d709fdfe70b5a4edbb42f855 

**242개 지갑에 총 133.1 ETH를 전송했고, 이때 소모된 gas limit 은 8,528,162입니다.**

**하나의 트랜잭션에서 이더리움을 보내고, 이 트랜잭션을 242번 반복했다면, 이때 소모된 gas limit 은 21,000 * 242= 5,082,000 이었을 것입니다.**

**이 트랜잭션은 컨트랙트를 사용해 이더리움을 한꺼번에 보내면서 블록체인 기록에 등록되는 수수료를 오히려 더 많이 썼습니다.<br><br><br>**

**(1) 1번 트랜잭션과 2번 트랜잭션에는 어떤 차이가 있길래 수수료에 차이가 발생했을까요? 기술적인 내용을 포함하지 않고 추론해보자.**

**철수는 이러한 사실을 활용해서 어떻게 자신의 이더리움 전송 수수료를 최소화 할 수 있을까? (철수는 위 트랜잭션의 스마트 컨트랙트를 사용합니다. 새로운 스마트 컨트랙트를 작성하지 않습니다) <br><br>**

**(2)이더리움의 가스 산정 방식을 기반으로, 왜 이러한 결과가 나타났을까?** 

---

***[Answer]***

**수수료가 싸진 1번 트랜잭션의 특징**  
- 425개 지갑에 총 216.75 ETH를 전송하면서 `gas limit` 4,335,552 소모  
- 만약 각각 425건의 단일 트랜잭션(기본 전송, 21,000 gas)으로 전송했다면 8,925,000 gas 소모  
- 즉, "여러 주소로 한꺼번에 보내는" 스마트 컨트랙트가 **매우 효율적으로 동작**하여, 개별 전송 대비 가스 사용량이 절반 이하로 줄어든 경우  
    - 이 상황에서는 다음 계산에 의해 배치 전송이 상당한 이점을 제공.
    <!-- $$
    \text{Total Gas Savings} \approx 8{,}925{,}000 - 4{,}335{,}552 \approx 4{,}589{,}448
    $$ -->
    - ![Total Gas Savings](https://latex.codecogs.com/svg.latex?\color{green}\text{Total%20Gas%20Savings}%20\approx%208\;925\;000%20-%204\;335\;552%20\approx%204\;589\;448)


**수수료가 오히려 비싸진 2번 트랜잭션의 특징**  
- 242개 지갑에 총 133.1 ETH를 전송하면서 `gas limit` 8,528,162 소모  
- 각각 242건의 단일 트랜잭션(기본 전송, 21,000 gas)으로 전송했다면 5,082,000 gas 소모  
- 즉, 동일하게 "여러 주소로 한꺼번에 보내는" 방식이지만, **내부적으로 처리하는 작업이 많아** 결과적으로 개별 전송보다 가스 사용량이 더 커진 경우  
    - 여기서는 다음 계산에 의해 예상 밖의 추가 비용이 발생.
    <!-- $$
    \text{Gas Increase} \approx 8{,}528{,}162 - 5{,}082{,}000 \approx 3{,}446{,}162
    $$ -->
    - ![Gas Increase](https://latex.codecogs.com/svg.latex?\color{green}\text{Gas%20Increase}%20\approx%208\;528\;162%20-%205\;082\;000%20\approx%203\;446\;162)



#### (1) 두 트랜잭션의 차이에 대한 추론과, 철수가 수수료를 최소화하는 방법

- **[1] 1번 트랜잭션과 2번 트랜잭션의 차이 (정성적 분석)**  
  - 두 트랜잭션 모두 “한 번의 트랜잭션으로 여러 명에게 이더(ETH)를 보낸다”는 점은 동일합니다. 그럼에도 1번 트랜잭션(425곳 전송)은 “개별 전송 대비 가스가 절반 이하”로 줄어든 반면, 2번 트랜잭션(242곳 전송)은 “개별 전송보다 가스가 더 비싼” 결과가 나왔습니다.  
  - 이는 배치(일괄) 전송 로직을 구현한 **스마트 컨트랙트**의 내부 연산이 얼마나 간소화되어 있느냐(여분의 데이터 쓰기, 이벤트 로깅, 검증 로직 등), 그리고 **호출 과정에서 얼마나 많은 부수 작업**이 발생하느냐에 따라 크게 달라집니다.
    - **1번 트랜잭션의 컨트랙트**  
      - 반복문(Loop)으로 “(주소, 금액) 쌍”을 순회하더라도, **중간 상태 변경(State change)이 최소화**되었을 가능성이 높습니다.  
      - 즉, 단순 ETH 전송(내장 `call`) 정도만 실행하여 `SSTORE`(스토리지 기록)나 **여러 이벤트(LOG)** 발행을 최대한 줄였을 수 있습니다.  
      - 결과적으로 $G_\text{loop}$(반복 1회당 가스)가 작아져, 전체 가스가 크게 절감되는 효과를 얻은 것으로 보입니다.
    - **2번 트랜잭션의 컨트랙트**  
      - ETH 전송과 더불어, **추가 검증 로직**, 회계 처리, 내부 상태 갱신(SSTORE), 이벤트 로그 발생이 **반복적으로** 실행되었을 가능성이 큽니다.  
      - 이 경우 $G_\text{loop}$가 훨씬 커지며, 루프 전체를 수행하는 동안의 누적 가스가 **개별 전송보다도 비싼** 결과로 이어집니다.  
      - 예컨대 스마트 컨트랙트가 각 전송 시점마다 “수취자별 상태 업데이트”를 SSTORE에 기록한다면, `SSTORE`마다 5,000~20,000 가스가 추가될 수 있어 총합이 커집니다.  
      - 실제로 이더리움 옐로 페이퍼(예: Appendix G)에서는 `SSTORE` 연산의 비용이 기존 스토리지가 0에서 0이 아닌 값으로 변경되는지, 0이 아닌 값에서 0으로 변경되는지에 따라 가변적으로 책정된다고 명시하고 있습니다.

- **[2] 철수가 수수료를 최소화하는 방법**  
  - 철수는 “(1)번 트랜잭션에 사용된 것과 유사한 스마트 컨트랙트 기능”을 확인하고, 해당 컨트랙트 또는 동일한 구현체를 찾아 **직접 호출**하면 됩니다.  
  - 실제로 컨트랙트를 호출하기 전에, **소액 테스트**로 가스 사용량을 확인해야 합니다. 1번 트랜잭션에서 사용된 동일 컨트랙트라도, 인자(주소 수, 금액 배열 등)에 따라 가스 비용이 달라질 수 있습니다.  
  - **가능한 전략**:
    1. **배치 송금 함수**를 호출하되, **중간에 추가 연산(이벤트 기록, 스토리지 변경)이 없는** 순수 전송 형태로만 사용한다.  
    2. 1번 트랜잭션에서 확인된 방식과 유사하게, `address[] 배열 + 금액 배열` 등의 단순 파라미터 구조만 사용하고, **추가 기능**(검증 로직, 상태 저장)을 되도록 배제한다.  
    3. **테스트 트랜잭션**(2~3개의 지갑 대상)을 먼저 실행해 가스 사용량을 관찰하고, 만족스러운 결과가 나오면 100개 지갑 전송을 진행한다.  
  - 이 때, 이더리움 네트워크 혼잡도(가스비 가격, Gwei 수준)도 중요합니다. 혼잡 시점에 배치 송금을 해도 전체 가스비는 비싸질 수 있으므로, **혼잡도가 낮은 시간**에 송금하는 것도 방법입니다.

```solidity

    /**
    * 예시: 단순화된 배치 전송 컨트랙트
    * 실제 프로덕션 환경에서는 보안 이슈(예: 재진입 등) 고려 필요
    */
    pragma solidity ^0.8.0;

    contract SimpleBatchTransfer {
        function batchSendETH(address[] memory recipients, uint256[] memory amounts) public payable {
            require(recipients.length == amounts.length, "Data length mismatch");
            for (uint256 i = 0; i < recipients.length; i++) {
                // 단순 ETH 전송 외에 추가 SSTORE나 LOG를 하지 않음
                (bool success, ) = recipients[i].call{value: amounts[i]}("");
                require(success, "Transfer failed");
            }
        }
    }
```
- 위와 같은 단순화된 로직의 경우, 내부적으로 `call` 함수만을 반복하여 스토리지를 갱신하거나 이벤트를 발생시키지 않기 때문에, $G_\text{loop}$가 상대적으로 낮을 수 있습니다. 하지만 네트워크 상황, 수취 지갑 주소의 상태(예: 새로 생성된 EOA인지 등)에 따라 실제 가스 비용은 달라질 수 있습니다.

#### (2) 이더리움의 가스 산정 방식을 기반으로, 왜 이러한 결과가 나타났는가

이더리움에서는 **트랜잭션 수행 시 발생하는 모든 연산**에 대해 가스 비용이 부과됩니다. 특히 다음 항목들이 핵심입니다:

1. **기본 전송(EOA → EOA) 비용**  
   - 아무 로직 없이 개인 지갑(EOA) → 개인 지갑(EOA)으로 ETH를 전송하는 경우, $ \text{Gas} = \text{21,000} $  
   - 이 21,000 가스는 *base transaction cost*로서, *EVM opcode* 측면에서 가장 기본적인 value transfer 비용입니다. 옐로 페이퍼 (예: Equation (61))에서도 트랜잭션 처리에 대한 기본 비용을 정의합니다.
   - 가스비는 네트워크 상태 및 블록 가스 한도에 따라 달라질 수 있으며, 혼잡 시에는 <b>가스 가격</b>이 상승해 실제 비용이 더 높아질 수 있습니다.
   - EIP-1559 이후에는 베이스 가스비(Base Fee)와 팁(Tip) 구조로 변경되었으며, 사용자는 트랜잭션 우선순위를 위해 팁을 조정할 수 있습니다.

2. **스마트 컨트랙트 호출 시 추가 연산**  
   - 컨트랙트 내부에서 반복문(Loop), 조건문, 스토리지 쓰기(`SSTORE`), 이벤트(`LOG`) 발생 등을 할 때마다 EVM(이더리움 가상머신)은 <b>옵코드 리스트(opcodelist)</b>에 따라 추가 가스를 청구합니다.  
   - 예컨대,
     - $SSTORE$ 시 **5,000 ~ 20,000 가스** 정도가 소모될 수 있음 (기존 값이 0인지, 변경 후가 0인지 등 상황에 따라 달라짐; 옐로 페이퍼 Appendix G 참고)  
     - $LOG$ (이벤트 로깅) 시 데이터 길이에 비례해 가스가 추가됨  
     - $CALL$ (ETH 전송) 자체도 **700가스**(EIP-150 이후) 이상의 기본 비용을 요구하며, 상황에 따라 더 오버헤드가 발생할 수 있음

3. **반복 호출 vs. 배치 호출 → 롤업**  
   - 개별 송금 N번을 할 경우, 각 송금마다 `base 21,000 가스`가 발생하므로, 총 가스는 $21{,}000 \times N$
   - 배치 송금을 스마트 컨트랙트가 처리할 경우, 다음과 같이 표현할 수 있습니다:

    <!-- $$
     \text{Total Gas} = G_\text{base} \;+\; (G_\text{loop} \times N) \;+\; G_\text{extra}
    $$ -->
    - ![Total Gas](https://latex.codecogs.com/svg.latex?\color{green}\text{Total%20Gas}%20=%20G_\text{base}%20+%20(G_\text{loop}%20\times%20N)%20+%20G_\text{extra})


     - $G_\text{base}$: 컨트랙트를 호출하는 데 필요한 기본 비용 (트랜잭션 자체의 베이스 비용, 약 21,000 + α)  
     - $G_\text{loop}$: “각 주소에 송금” 루프를 돌 때 발생하는 1회당 가스량 (예: ETH 전송, 간단 검증 등)  
     - $G_\text{extra}$: 추가 기능(예: 스토리지 업데이트, 이중 검증 로직)으로 인한 고정 비용 또는 반복당 누적 비용 등  
   
   - **배치 송금이 이득이 되려면**,  

    <!-- $$
    G_\text{base} + (G_\text{loop} \times N) + G_\text{extra} \;<\; 21{,}000 \times N
    $$   -->
    - ![Gas Cost Formula](https://latex.codecogs.com/svg.latex?\color{green}G_\text{base}%20+%20(G_\text{loop}%20\times%20N)%20+%20G_\text{extra}%20<%2021{,}000%20\times%20N)

     이 성립해야 합니다. 즉, 스마트 컨트랙트 호출의 고정 비용($G_\text{base}$) + 루프 비용($G_\text{loop}$) + 추가 기능($G_\text{extra}$)의 합이, 개별 송금 총비용보다 작아야 “가스 절약”이 가능합니다.
   
   - <b>이더리움 레이어2</b> : 배치 호출의 확장, 롤업
      - 롤업은 여러 개의 트랜잭션 데이터를 "오프체인"에서 처리한 후, 이를 압축하여 "온체인"에 기록합니다.
      - 이 과정에서 롤업은 배치 호출의 원리를 활용하되, 데이터 압축과 검증 로직을 추가하여 확장성을 크게 높입니다.
      - 예를 들어, 롤업은 오프체인에서 모든 연산과 검증을 수행한 뒤, 결과값(상태 루트)을 이더리움 메인넷에 제출하여 네트워크 부하를 줄입니다.

<img src="https://raw.githubusercontent.com/songyongjae/Hands-On-SQC/main/src/figure/fig4.jpg" alt="Flashbots Simulator Algorithm" style="width:650px;max-width:100%;">

4. **1번 트랜잭션(가스 절약) vs 2번 트랜잭션(가스 증가)**  
   - **1번 트랜잭션**  
     - 내부 반복문이 **단순 ETH 송금** 중심으로 최적화되어, $G_\text{loop}$가 상당히 작았던 것으로 보입니다.  
     - 이벤트(LOG)나 스토리지(SSTORE) 업데이트를 최소화했다면, 반복 425회에도 불구하고 독립 송금(21,000×425)보다 훨씬 적은 총가스를 달성할 수 있습니다.  
     - 예컨대, EVM에서 `CALL`(ETH 전송)만 반복해서 사용하고 추가 데이터 쓰기가 거의 없었다면, 배치 처리가 오히려 효율적일 수 있습니다.  
   - **2번 트랜잭션**  
     - 내부에 상태 갱신, 검증 로직, 이벤트 발생 등 부수 작업이 많이 포함된 것으로 추정됩니다.  
     - 반복 242회에 대해 각각 `SSTORE, LOG, CALL` 등을 중첩 수행하면서 $G_\text{loop}$가 매우 커지고, 추가 고정 비용($G_\text{extra}$) 역시 높아져, 결국 단일 송금 대비 가스 소비가 증가한 결과를 낳았습니다.  
     - 이는 옐로 페이퍼의 가스 비용 정의(Eq. (200) 전후)와 EIP-2028(트랜잭션 입력 데이터 비용 절감 규정) 등에서 “데이터 쓰기”가 얼마나 비용이 큰지 과학적으로 설명됩니다.

**결론**  
- 철수가 10 ETH를 100개 지갑에 분산하려면, **배치 송금용 컨트랙트**를 활용해 가스가 절약되는 로직을 찾는 것이 핵심입니다.  
- 그러나 “배치 송금이면 무조건 싸다”는 오해일 수 있습니다. 컨트랙트 내부 연산(스토리지 기록, 이벤트 로깅, 복잡한 검증 루틴 등)이 많으면, 오히려 개별 송금보다 비싸질 수도 있습니다.  
- 실제로 철수는, 1번 트랜잭션처럼 **가스 절약 효과가 입증된 컨트랙트**를 사용하거나, 또는 소규모 전송으로 **가스 사용량을 사전 시험**한 뒤 본격적인 대량 전송을 해야 합니다.  
- 이더리움의 가스 비용은 EVM **opcode** 단위로 세밀하게 측정되며, 배치 트랜잭션이 진정한 이점을 발휘하려면 반복 처리(루프)에 드는 부가비용을 최소화해야 한다는 점이 **기술적 명분**(이더리움 옐로 페이퍼의 가스 정의, EIP-150, EIP-2028 등)으로 뒷받침됩니다.


